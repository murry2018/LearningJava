# 필드 초기화와 제한자

 자바 클래스에 선언하는 변수들을 필드라고 부른다.

## 초기화

 필드 초기화의 한 방법은 초기자(initializer)를 이용하는 것이다. 주로 상수, 상수 표현식, 메소드 호출 등이 가능하다. 초기자는 단순한 초기화에 사용하는 것이 바람직하며, 예외를 처리할 방법이 없으므로 예외가 발생하지 않도록 해야 한다. 이보다 복잡한 초기화는 생성자, 혹은 어노테이션 등 추가적인 도구를 이용한다.
 
 필드를 명시적으로 초기화하지 않을 경우, 타입에 맞는 적절한 기본 값으로 초기화된다.

| Type                   | Initial value |
|------------------------|---------------|
| boolean                | false         |
| char                   | '\\u0000'      |
| byte, short, int, long | 0             |
| float, double          | +0.0          |
| object reference       | null              |

## 초기화 블록

**예시 1**

```java
/**
 *  별로 인상적인 예시는 아니다.
 */
class Product {
    String wow;
    {
	wow = "Wow!";
    }
}
```

 필드를 초기화하는 다른 방법은 초기화 블록(initialization block)을 이용하는 것이다. 초기화 블록은 클래스의 모든 생성자에 앞서 실행되므로, 생성자마다 중복되는 작업을 모아두기에 유용하다. 혹여, 이 작업을 별도의 초기화 도움 함수(예컨대, `init()`)에서 수행하는 방식을 생각해 볼 수도 있다. 그러나 이런 식의 객체 생성 로직 분산은 그다지 좋은 생각이 아니다. 우선 클래스의 크기가 커져 한눈에 알아보기가 어렵고, 컴파일러는 도움 메서드를 생성자(혹은 그 일부)라고 여기지 않기 때문에 blank final 필드를 초기화 할 수 없다.
 
 초기화 블록의 또 다른 유용한 예는 익명 내부 클래스 객체의 초기화 작업이다. 익명 내부 클래스는 이름을 갖지 않기 때문에 생성자를 가질 수 없지만, 초기화 블록을 통해 적절한 초기화를 수행해줄 수 있다.
 
 초기자와 달리, 초기화 블록에서는 예외를 발생시킬 수 있다. 이 때 발생하는 예외는 Checked Exception이어야 한다. 중요한 것은, 초기화 블록에는 `throws` 선언을 할 수 없으므로 클래스의 모든 생성자에서 그 예외에 대한 `throws` 선언을 해야 한다는 것이다.

### static 초기화 블럭

**예시 2**

```java
class Fibonacci {
    private static long Fibonacci[];
    static {
	Fibonacci = new long[32];
	Fibonacci[0] = 0;
	Fibonacci[1] = 1;
	for (int i = 2; i < 32; i++) {
	    Fibonacci[i] = Fibonacci[i-1] + Fibonacci[i-2];
	}
    }
}
```

앞선 섹션에서 살펴본 초기화 블록은 객체 생성과 함께 돌아간다. 따라서
static 필드를 초기화하는데는 그다지 알맞지 않다. static 필드는 static
초기화 블럭을 통해 초기화한다. static 초기화 블럭은 클래스가 로드되는
동안 수행되므로, 프로그램의 실행 주기 동안 단 한 번 실행된다.

이 단계에서는 객체가 없으므로 오직 static 필드에만 접근할 수 있고,
예외 처리를 할 수 없으므로 어떤 예외도 발생시키지 않는 편이 좋다.

## 초기화의 순서

정리하면, 클래스가 JVM에 로드될 때 정적 초기화<sub>static initializing</sub>가 일어나고, 객체 생성 시
비정적<sub>non-static</sub> 초기화가 일어난다. 이 초기화들 사이의 순서는 코드로 쓰인 순서대로 일어난다.

한 편, 한 클래스를 초기화 하는 도중 다른 클래스의 메소드를 불러 온다면 어떻게 될까? \<자바 프로그래밍
언어\>에서는 그러한 상황을 다음과 같이 묘사한다.

> X 클래스의 정적 초기자는 Y 클래스의 메소드를 호출하고, Y 클래스의 정적 초기자는 정적 값을 설정하기 위해서 X 클래스의 메소드를 호출한다면 어떻게 될까? 이런 순환적인 초기화는 컴파일할 때는 확실하게 찾아낼 수 없다. 왜냐하면 Y의 코드는 X를 컴파일할 때는 작성되어 있지 않을 수 있기 때문이다. 이러한 순환이 일어나면 X의 정적 초기자는 오직 Y메소드가 호출된 곳에서만 실행될 것이다. 반대로 Y에서 X의 메소드를 호출할 때, X의 메소드는 실행되어야 할 정적 초기자의 나머지 부분을 실행한다. X에 있는, 초기자를 가지지 않는 정적 필드들은 여전히 기본 값으로 설정되어 있을 것이다.

## 제한자

필드 선언 앞에 제한자를 둠으로써 몇 가지 속성을 부여할 수 있다.

- 어노테이션(annotation)
- 접근 제한자(access modifier) - [자바의 Data Hiding과 접근 제어자](Data-Hiding-and-Access-Modifier.md)를 보라.
- static - 한 클래스의 모든 인스턴스에 공유되는 필드를 나타낸다.
- final - 초기화 된 이후 변경할 수 없는 필드를 나타낸다.
- transient - 객체 직렬화와 관련이 있다.
- volatile - 동기화, 혹은 메모리 모델과 연관된 속성이다.

final이면서 동시에 volatile인 필드는 만들 수 없다. 여러 제한자를 같은 필드에 선언하고자 한다면 위에 나열한 순서대로 쓸 것을 권장한다.

> **final에 대해 더 자세히...**
>
> 초기자를 통해 초기화되지 않은 final 필드를 blank final 이라 부르는데, static 필드의 경우 클래스가 초기화 되는 시점에, non-static 필드의 경우 객체가 생성되는 시점에 초기화되어야 한다.
>
> 문자열이나 원시타입의 경우, 컴파일 시간에 값이 결정되기 때문에 constant variable 이라 불린다. constant variable 들은 특별해서, 바이트코드로 변환될 때 참조 대신 값이 바로 적재된다. 이 때문에 직렬화 시 추가적으로 고려해야할 사항이 있다. 여러 스레드에서 동시에 접근할 때도 final 필드는 특별한 의미를 갖는다.
